{% extends "base.html" %}

{% block content %}
  <h1>Your Playlists</h1>
  <div class="actions">
    <a class="btn secondary" href="{{ url_for('logout') }}">Disconnect</a>
  </div>
  <div class="meta">
    Total playlists: {{ total_playlists }} · Total videos: <span id="total-videos">{{ total_videos }}</span>
    · API calls used (today): {{ api_calls_used }}
    {% if api_calls_remaining is not none %}
      · Estimated remaining: {{ api_calls_remaining }}
    {% endif %}
  </div>
  <form method="get">
    <div class="actions">
      <label>
        Sort by
        <select name="sort">
          <option value="title" {% if sort_by == "title" %}selected{% endif %}>Title</option>
          <option value="count" {% if sort_by == "count" %}selected{% endif %}>Video count</option>
        </select>
      </label>
      <label>
        Order
        <select name="order">
          <option value="asc" {% if sort_order == "asc" %}selected{% endif %}>Ascending</option>
          <option value="desc" {% if sort_order == "desc" %}selected{% endif %}>Descending</option>
        </select>
      </label>
      <button class="btn" type="submit">Apply</button>
    </div>
    <div class="actions">
      <label>
        Max videos
        <input type="number" id="count-threshold" min="0" step="1" placeholder="e.g. 10">
      </label>
      <button class="btn secondary" type="button" id="select-by-count">Select ≤ X</button>
    </div>
    <div class="actions">
      <label>
        Search
        <input type="text" id="playlist-search" placeholder="Type to filter playlists">
      </label>
    </div>
  </form>
  {% if playlists %}
    <div class="playlist-layout">
      <div class="playlist-list-pane">
        <div class="bulk-actions actions">
          <button class="btn danger" type="button" id="delete-selected" style="display: none;" disabled>Delete selected</button>
          <button class="btn secondary" type="button" id="merge-selected" style="display: none;" disabled onclick="document.getElementById('merge-status').textContent='Merge button clicked.'; startMerge(event);">Merge selected</button>
          <span id="merge-status" class="merge-status"></span>
        </div>
        <ul class="playlist-list" id="playlist-list">
          {% for playlist in playlists %}
            <li data-playlist-id="{{ playlist.id }}" data-count="{{ playlist.contentDetails.itemCount }}">
              <input type="checkbox" class="playlist-select">
              <form method="post" class="delete-form" action="{{ url_for('delete_playlist', playlist_id=playlist.id, sort=sort_by, order=sort_order) }}">
                <button class="btn danger" type="submit">Delete</button>
              </form>
              <button class="btn secondary view-button" type="button" data-playlist-id="{{ playlist.id }}">
                View
              </button>
              <button class="btn secondary rename-button" type="button" data-playlist-id="{{ playlist.id }}">
                Rename
              </button>
              <button class="btn secondary dedupe-button" type="button" data-playlist-id="{{ playlist.id }}">
                Dedupe
              </button>
              <span class="dedupe-status" aria-live="polite"></span>
              <div class="playlist-info">
                <div>
                  <strong>
                    <a class="playlist-link" href="https://www.youtube.com/playlist?list={{ playlist.id }}" target="_blank" rel="noopener noreferrer" data-title="{{ playlist.snippet.title }}">
                      {{ playlist.snippet.title }}
                    </a>
                  </strong>
                </div>
                <div class="meta">
                  {{ playlist.contentDetails.itemCount }} videos
                </div>
              </div>
            </li>
          {% endfor %}
        </ul>
      </div>
      <div class="playlist-viewer-pane">
        <div class="viewer-header">
          <div>
            <div id="playlist-viewer-title">Playlist videos</div>
            <div id="playlist-viewer-info" class="viewer-status"></div>
            <div id="playlist-viewer-status" class="viewer-status"></div>
          </div>
          <div class="viewer-actions">
            <label>
              Destination
              <select id="transfer-destination" disabled>
                <option value="">Select playlist</option>
              </select>
            </label>
            <button class="btn secondary" type="button" id="copy-selected-videos" disabled>Copy selected</button>
            <button class="btn secondary" type="button" id="move-selected-videos" disabled>Move selected</button>
            <button class="btn danger" type="button" id="delete-selected-videos" disabled>Delete selected videos</button>
            <button class="btn secondary" type="button" id="import-videos-button">Import videos</button>
          </div>
        </div>
        <div id="playlist-viewer" class="viewer-list">
          <div class="viewer-hint">Select a playlist to load its videos.</div>
        </div>
      </div>
    </div>
    <div id="import-modal-overlay" class="import-modal-overlay">
      <div class="import-modal">
        <h3>Import videos</h3>
        <label>
          Destination playlist
          <select id="import-destination">
            {% for playlist in playlists %}
              <option value="{{ playlist.id }}">{{ playlist.snippet.title }}</option>
            {% endfor %}
          </select>
        </label>
        <div style="margin-top: 12px;">
          <label>
            Paste YouTube URLs, video IDs, or CSV content:
          </label>
          <textarea id="import-textarea" placeholder="https://www.youtube.com/watch?v=dQw4w9WgXcQ&#10;https://youtu.be/abc123&#10;or paste Google Takeout CSV..."></textarea>
        </div>
        <div style="margin-top: 8px;">
          <label>
            Or upload a file (.csv, .txt):
            <input type="file" id="import-file" accept=".csv,.txt">
          </label>
        </div>
        <div id="import-status" class="import-status"></div>
        <div class="actions">
          <button class="btn" type="button" id="import-submit">Import</button>
          <button class="btn secondary" type="button" id="import-cancel">Cancel</button>
        </div>
      </div>
    </div>
  {% else %}
    <p>No playlists found.</p>
  {% endif %}

  <script>
    const viewer = document.getElementById('playlist-viewer');
    const bulkDeleteButton = document.getElementById('delete-selected');
    const mergeSelectedButton = document.getElementById('merge-selected');
    const mergeStatus = document.getElementById('merge-status');
    const playlistSearch = document.getElementById('playlist-search');
    const playlistList = document.getElementById('playlist-list');
    const totalVideosEl = document.getElementById('total-videos');
    let searchTimer = null;
    const countInput = document.getElementById('count-threshold');

    const viewerTitle = document.getElementById('playlist-viewer-title');
    const viewerInfo = document.getElementById('playlist-viewer-info');
    const viewerStatus = document.getElementById('playlist-viewer-status');
    const deleteSelectedVideosButton = document.getElementById('delete-selected-videos');
    const copySelectedVideosButton = document.getElementById('copy-selected-videos');
    const moveSelectedVideosButton = document.getElementById('move-selected-videos');
    const transferDestinationSelect = document.getElementById('transfer-destination');
    let currentPlaylistId = null;
    const videoCache = {};
    let isLoadingMore = false;
    let scrollCleanup = null;

    function createVideoListItem(item) {
      const title = item?.title || 'Untitled video';
      const thumbUrl = item?.thumbnail || '';
      const videoId = item?.videoId;
      const playlistItemId = item?.playlistItemId;
      const listItem = document.createElement('li');
      listItem.dataset.playlistItemId = playlistItemId || '';
      listItem.dataset.videoId = videoId || '';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'video-select';
      const thumb = document.createElement('img');
      thumb.className = 'video-thumb';
      thumb.alt = '';
      if (thumbUrl) {
        thumb.src = thumbUrl;
      }
      const link = document.createElement('a');
      link.textContent = title;
      if (videoId) {
        link.href = `https://www.youtube.com/watch?v=${videoId}`;
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
      }
      checkbox.addEventListener('change', () => {
        updateVideoDeleteState();
        updateTransferState();
      });
      listItem.appendChild(checkbox);
      listItem.appendChild(thumb);
      listItem.appendChild(link);
      return listItem;
    }

    function renderCachedItems(playlistId) {
      const cached = videoCache[playlistId];
      if (!cached || !cached.items.length) {
        viewer.innerHTML = '<div class="viewer-hint">No videos found.</div>';
        updateViewerInfo();
        return;
      }
      const list = document.createElement('ol');
      list.className = 'viewer-items';
      cached.items.forEach((item) => {
        list.appendChild(createVideoListItem(item));
      });
      viewer.innerHTML = '';
      viewer.appendChild(list);
      updateVideoDeleteState();
      updateTransferState();
      updateViewerInfo();
    }

    function loadMoreVideos(playlistId) {
      const cached = videoCache[playlistId];
      if (!cached || !cached.nextPageToken || isLoadingMore) return;
      isLoadingMore = true;
      const list = viewer.querySelector('.viewer-items');
      const loadingEl = document.createElement('div');
      loadingEl.className = 'scroll-loading';
      loadingEl.textContent = 'Loading more...';
      if (list) list.after(loadingEl);
      fetch(`/playlist/${playlistId}/items?pageToken=${encodeURIComponent(cached.nextPageToken)}`)
        .then((response) => response.json())
        .then((data) => {
          if (currentPlaylistId !== playlistId) return;
          const newItems = data.items || [];
          cached.items.push(...newItems);
          cached.nextPageToken = data.nextPageToken || null;
          if (list) {
            newItems.forEach((item) => {
              list.appendChild(createVideoListItem(item));
            });
          }
          updateViewerInfo();
        })
        .catch(() => {
          /* silently fail, user can scroll again */
        })
        .finally(() => {
          loadingEl.remove();
          isLoadingMore = false;
        });
    }

    function setupInfiniteScroll(playlistId) {
      if (scrollCleanup) {
        scrollCleanup();
        scrollCleanup = null;
      }
      const cached = videoCache[playlistId];
      if (!cached?.nextPageToken) return;
      function onScroll() {
        if (isLoadingMore) return;
        if (currentPlaylistId !== playlistId) {
          viewer.removeEventListener('scroll', onScroll);
          scrollCleanup = null;
          return;
        }
        const c = videoCache[playlistId];
        if (!c?.nextPageToken) {
          viewer.removeEventListener('scroll', onScroll);
          scrollCleanup = null;
          return;
        }
        if (viewer.scrollTop + viewer.clientHeight >= viewer.scrollHeight - 200) {
          loadMoreVideos(playlistId);
        }
      }
      viewer.addEventListener('scroll', onScroll);
      scrollCleanup = () => viewer.removeEventListener('scroll', onScroll);
    }

    function updateViewerInfo() {
      if (!viewerInfo || !currentPlaylistId) return;
      const row = document.querySelector(`.playlist-list li[data-playlist-id="${currentPlaylistId}"]`);
      const totalCount = row ? parseInt(row.dataset.count || '0', 10) : 0;
      const cached = videoCache[currentPlaylistId];
      const loadedCount = cached ? cached.items.length : 0;
      const selectedCount = viewer.querySelectorAll('.video-select:checked').length;
      let text = `${loadedCount} of ${totalCount} videos`;
      if (selectedCount > 0) {
        text += ` · ${selectedCount} selected`;
      }
      viewerInfo.textContent = text;
    }

    function updateVideoDeleteState() {
      if (!deleteSelectedVideosButton) return;
      const anySelected = viewer.querySelectorAll('.video-select:checked').length > 0;
      deleteSelectedVideosButton.disabled = !anySelected;
      updateViewerInfo();
    }

    function updateTransferState() {
      if (!copySelectedVideosButton || !moveSelectedVideosButton || !transferDestinationSelect) return;
      const anySelected = viewer.querySelectorAll('.video-select:checked').length > 0;
      const hasDestination = Boolean(transferDestinationSelect.value);
      copySelectedVideosButton.disabled = !anySelected || !hasDestination;
      moveSelectedVideosButton.disabled = !anySelected || !hasDestination;
    }

    function updateDestinationOptions() {
      if (!transferDestinationSelect) return;
      const options = Array.from(document.querySelectorAll('.playlist-list li'))
        .map((row) => {
          const title = row.querySelector('.playlist-link')?.textContent?.trim() || '';
          return { id: row.dataset.playlistId, title };
        })
        .filter((item) => item.id && item.id !== currentPlaylistId);
      transferDestinationSelect.innerHTML = '<option value="">Select playlist</option>';
      options.forEach((item) => {
        const option = document.createElement('option');
        option.value = item.id;
        option.textContent = item.title;
        transferDestinationSelect.appendChild(option);
      });
      transferDestinationSelect.disabled = options.length === 0;
      updateTransferState();
    }

    function loadPlaylistVideos(playlistId, playlistTitle, rowElement) {
      if (!playlistId) return;
      currentPlaylistId = playlistId;
      if (viewerTitle && playlistTitle) {
        viewerTitle.textContent = `Playlist videos: ${playlistTitle}`;
      }
      if (viewerInfo) {
        viewerInfo.textContent = '';
      }
      if (viewerStatus) {
        viewerStatus.textContent = '';
      }
      document.querySelectorAll('.playlist-list li').forEach((li) => {
        li.classList.remove('active');
      });
      if (rowElement) {
        rowElement.classList.add('active');
      }
      updateDestinationOptions();

      if (videoCache[playlistId]) {
        renderCachedItems(playlistId);
        setupInfiniteScroll(playlistId);
        return;
      }

      viewer.innerHTML = '<div class="viewer-hint">Loading...</div>';
      fetch(`/playlist/${playlistId}/items`)
        .then((response) => response.json())
        .then((data) => {
          if (currentPlaylistId !== playlistId) return;
          const items = data.items || [];
          videoCache[playlistId] = {
            items: items,
            nextPageToken: data.nextPageToken || null,
          };
          renderCachedItems(playlistId);
          setupInfiniteScroll(playlistId);
        })
        .catch(() => {
          viewer.innerHTML = '<div class="viewer-hint">Failed to load videos.</div>';
        });
    }

    document.querySelectorAll('.view-button').forEach((button) => {
      button.addEventListener('click', () => {
        const li = button.closest('li');
        const title = li ? li.querySelector('.playlist-link')?.textContent?.trim() : '';
        loadPlaylistVideos(button.dataset.playlistId, title, li);
      });
    });

    document.querySelectorAll('.rename-button').forEach((button) => {
      button.addEventListener('click', () => {
        const li = button.closest('li');
        const playlistId = li?.dataset.playlistId || button.dataset.playlistId;
        if (!playlistId) return;
        const currentTitle = li?.querySelector('.playlist-link')?.textContent?.trim() || '';
        const newName = prompt('New playlist name', currentTitle);
        if (!newName) return;
        const trimmed = newName.trim();
        if (!trimmed) return;
        button.disabled = true;
        const originalLabel = button.textContent;
        button.textContent = 'Renaming...';
        fetch(`/playlist/${playlistId}/rename`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest',
          },
          body: JSON.stringify({ name: trimmed }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (!data.success) {
              alert(data.error || 'Failed to rename playlist.');
              return;
            }
            const link = li?.querySelector('.playlist-link');
            if (link) {
              link.textContent = data.name || trimmed;
              link.dataset.title = data.name || trimmed;
            }
            if (viewerTitle && currentPlaylistId === playlistId) {
              viewerTitle.textContent = `Playlist videos: ${data.name || trimmed}`;
            }
            updateDestinationOptions();
          })
          .catch(() => {
            alert('Failed to rename playlist.');
          })
          .finally(() => {
            button.textContent = originalLabel;
            button.disabled = false;
          });
      });
    });

    document.querySelectorAll('.dedupe-button').forEach((button) => {
      button.addEventListener('click', () => {
        const li = button.closest('li');
        const playlistId = li?.dataset.playlistId || button.dataset.playlistId;
        if (!playlistId) return;
        if (!confirm('Remove duplicate videos from this playlist?')) return;
        const statusEl = li ? li.querySelector('.dedupe-status') : null;
        button.disabled = true;
        const originalLabel = button.textContent;
        button.textContent = 'Removing...';
        if (statusEl) {
          statusEl.textContent = 'Removing duplicates...';
          statusEl.classList.remove('error');
        }
        fetch(`/playlist/${playlistId}/dedupe`, {
          method: 'POST',
          headers: { 'X-Requested-With': 'XMLHttpRequest' },
        })
          .then((response) => response.json())
          .then((data) => {
            if (!data.success) {
              if (statusEl) {
                statusEl.textContent = data.error || 'Failed to remove duplicates.';
                statusEl.classList.add('error');
              } else {
                alert(data.error || 'Failed to remove duplicates.');
              }
              return;
            }
            const remaining = data.remaining;
            if (li && Number.isFinite(remaining)) {
              li.dataset.count = `${remaining}`;
              const metaEl = li.querySelector('.meta');
              if (metaEl) metaEl.textContent = `${remaining} videos`;
            }
            const removedCount = data.removed || 0;
            if (totalVideosEl && Number.isFinite(removedCount)) {
              const currentTotal = parseInt(totalVideosEl.textContent || '0', 10);
              if (!Number.isNaN(currentTotal)) {
                totalVideosEl.textContent = `${Math.max(currentTotal - removedCount, 0)}`;
              }
            }
            delete videoCache[playlistId];
            if (currentPlaylistId === playlistId) {
              const title = li ? li.querySelector('.playlist-link')?.textContent?.trim() : '';
              loadPlaylistVideos(playlistId, title, li);
            }
            if (statusEl) {
              if (data.failures && data.failures.length) {
                statusEl.textContent = `Removed ${removedCount} duplicate(s), but some failed.`;
                statusEl.classList.add('error');
              } else {
                statusEl.textContent = `Removed ${removedCount} duplicate(s).`;
              }
              setTimeout(() => {
                statusEl.textContent = '';
                statusEl.classList.remove('error');
              }, 2000);
            }
          })
          .catch(() => {
            if (statusEl) {
              statusEl.textContent = 'Failed to remove duplicates.';
              statusEl.classList.add('error');
            } else {
              alert('Failed to remove duplicates.');
            }
          })
          .finally(() => {
            button.textContent = originalLabel;
            button.disabled = false;
          });
      });
    });

    document.querySelectorAll('.playlist-list li').forEach((row) => {
      row.addEventListener('click', (event) => {
        if (event.target.closest('button') || event.target.closest('a') || event.target.closest('input')) {
          return;
        }
        const title = row.querySelector('.playlist-link')?.textContent?.trim() || '';
        loadPlaylistVideos(row.dataset.playlistId, title, row);
      });
    });

    function applyPlaylistSearch(term) {
      const normalized = term.trim().toLowerCase();
      const rows = playlistList ? Array.from(playlistList.querySelectorAll('li')) : [];
      rows.forEach((row) => {
        const title = row.querySelector('.playlist-link')?.dataset.title || '';
        const matches = title.toLowerCase().includes(normalized);
        row.style.display = matches ? '' : 'none';
      });
    }

    if (playlistSearch) {
      playlistSearch.addEventListener('input', () => {
        if (searchTimer) {
          clearTimeout(searchTimer);
        }
        searchTimer = setTimeout(() => {
          applyPlaylistSearch(playlistSearch.value);
        }, 1000);
      });
    }

    function collectSelectedVideoItems() {
      return Array.from(viewer.querySelectorAll('.video-select:checked'))
        .map((checkbox) => checkbox.closest('li'))
        .filter(Boolean)
        .map((li) => ({
          li,
          playlistItemId: li.dataset.playlistItemId,
          videoId: li.dataset.videoId,
        }));
    }

    function updatePlaylistCount(playlistId, delta) {
      if (!playlistId || !Number.isFinite(delta)) return;
      const row = document.querySelector(`.playlist-list li[data-playlist-id="${playlistId}"]`);
      if (!row) return;
      const current = parseInt(row.dataset.count || '0', 10);
      if (Number.isNaN(current)) return;
      const next = Math.max(current + delta, 0);
      row.dataset.count = `${next}`;
      const metaEl = row.querySelector('.meta');
      if (metaEl) metaEl.textContent = `${next} videos`;
    }

    function updateTotalVideos(delta) {
      if (!totalVideosEl || !Number.isFinite(delta)) return;
      const currentTotal = parseInt(totalVideosEl.textContent || '0', 10);
      if (Number.isNaN(currentTotal)) return;
      totalVideosEl.textContent = `${Math.max(currentTotal + delta, 0)}`;
    }

    if (deleteSelectedVideosButton) {
      deleteSelectedVideosButton.addEventListener('click', () => {
        const selectedItems = collectSelectedVideoItems();
        if (!selectedItems.length || !currentPlaylistId) return;
        if (!confirm(`Remove ${selectedItems.length} video(s) from this playlist?`)) return;
        deleteSelectedVideosButton.disabled = true;
        const originalLabel = deleteSelectedVideosButton.textContent;
        deleteSelectedVideosButton.textContent = 'Deleting...';
        if (viewerStatus) {
          viewerStatus.textContent = `Removing: 0 of ${selectedItems.length}`;
        }
        const itemIds = selectedItems.map((item) => item.playlistItemId).filter(Boolean);
        fetch(`/playlist/${currentPlaylistId}/items/delete-bulk`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest',
          },
          body: JSON.stringify({ playlist_item_ids: itemIds }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (!data.success && data.failures && data.failures.length) {
              const failedIds = new Set(data.failures.map((item) => item.id));
              selectedItems.forEach((item) => {
                if (!failedIds.has(item.playlistItemId)) {
                  item.li.remove();
                }
              });
              alert('Some videos could not be removed.');
            } else {
              selectedItems.forEach((item) => item.li.remove());
            }
            if (viewerStatus) {
              viewerStatus.textContent = `Removing: ${selectedItems.length} of ${selectedItems.length}`;
            }
            const removedCount = data.failures && data.failures.length
              ? selectedItems.length - data.failures.length
              : selectedItems.length;
            if (videoCache[currentPlaylistId]) {
              const failedIds = data.failures ? new Set(data.failures.map((f) => f.id)) : new Set();
              const removedIds = new Set(
                selectedItems.map((item) => item.playlistItemId).filter((id) => id && !failedIds.has(id))
              );
              videoCache[currentPlaylistId].items = videoCache[currentPlaylistId].items
                .filter((item) => !removedIds.has(item.playlistItemId));
            }
            updatePlaylistCount(currentPlaylistId, -removedCount);
            updateTotalVideos(-removedCount);
            updateVideoDeleteState();
            updateTransferState();
          })
          .catch(() => {
            alert('Failed to remove videos.');
          })
          .finally(() => {
            deleteSelectedVideosButton.textContent = originalLabel;
            if (viewerStatus) {
              setTimeout(() => {
                viewerStatus.textContent = '';
              }, 1500);
            }
            updateVideoDeleteState();
            updateTransferState();
          });
      });
    }

    if (transferDestinationSelect) {
      transferDestinationSelect.addEventListener('change', updateTransferState);
    }

    function handleTransfer(mode) {
      const selectedItems = collectSelectedVideoItems();
      if (!selectedItems.length || !currentPlaylistId) return;
      const destinationId = transferDestinationSelect?.value;
      if (!destinationId) return;
      const actionLabel = mode === 'move' ? 'Move' : 'Copy';
      if (!confirm(`${actionLabel} ${selectedItems.length} video(s) to the selected playlist?`)) return;
      const button = mode === 'move' ? moveSelectedVideosButton : copySelectedVideosButton;
      if (!button) return;
      button.disabled = true;
      const originalLabel = button.textContent;
      button.textContent = `${actionLabel}ing...`;
      if (viewerStatus) {
        viewerStatus.textContent = `${actionLabel}ing: 0 of ${selectedItems.length}`;
      }
      const payloadItems = selectedItems.map((item) => ({
        videoId: item.videoId,
        playlistItemId: item.playlistItemId,
      }));
      fetch(`/playlist/${currentPlaylistId}/items/transfer`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
        },
        body: JSON.stringify({
          destination_id: destinationId,
          items: payloadItems,
          mode,
        }),
      })
        .then((response) => response.json())
        .then((data) => {
          if (!data.success && data.failures && data.failures.length) {
            alert('Some videos could not be transferred.');
          }
          const added = data.added || 0;
          const removed = data.removed || 0;
          delete videoCache[destinationId];
          if (mode === 'move' && removed) {
            selectedItems.forEach((item) => {
              if (item.playlistItemId) {
                item.li.remove();
              }
            });
            if (videoCache[currentPlaylistId]) {
              const movedIds = new Set(selectedItems.map((item) => item.playlistItemId).filter(Boolean));
              videoCache[currentPlaylistId].items = videoCache[currentPlaylistId].items
                .filter((item) => !movedIds.has(item.playlistItemId));
            }
            updatePlaylistCount(currentPlaylistId, -removed);
            updateTotalVideos(-removed);
          }
          if (added) {
            updatePlaylistCount(destinationId, added);
            if (mode === 'copy') {
              updateTotalVideos(added);
            }
          }
          if (viewerStatus) {
            viewerStatus.textContent = `${actionLabel}ing: ${selectedItems.length} of ${selectedItems.length}`;
            setTimeout(() => {
              viewerStatus.textContent = '';
            }, 1500);
          }
          updateVideoDeleteState();
          updateTransferState();
        })
        .catch(() => {
          alert('Failed to transfer videos.');
        })
        .finally(() => {
          button.textContent = originalLabel;
          button.disabled = false;
          updateVideoDeleteState();
          updateTransferState();
        });
    }

    if (copySelectedVideosButton) {
      copySelectedVideosButton.addEventListener('click', () => handleTransfer('copy'));
    }
    if (moveSelectedVideosButton) {
      moveSelectedVideosButton.addEventListener('click', () => handleTransfer('move'));
    }

    document.querySelectorAll('.delete-form').forEach((form) => {
      form.addEventListener('submit', (event) => {
        event.preventDefault();
        if (!confirm('Delete this playlist?')) return;
        fetch(form.action, {
          method: 'POST',
          headers: { 'X-Requested-With': 'XMLHttpRequest' },
        })
          .then((response) => response.json())
          .then((data) => {
            if (!data.success) {
              alert(data.error || 'Failed to delete playlist.');
              return;
            }
            const li = form.closest('li');
            const deletedPlaylistId = li?.dataset?.playlistId;
            if (deletedPlaylistId) delete videoCache[deletedPlaylistId];
            if (li) li.remove();
            updateBulkState();
          })
          .catch(() => {
            alert('Failed to delete playlist.');
          });
      });
    });

    function updateBulkState() {
      const anySelected = document.querySelectorAll('.playlist-select:checked').length > 0;
      const selectedCount = document.querySelectorAll('.playlist-select:checked').length;
      if (bulkDeleteButton) {
        bulkDeleteButton.disabled = !anySelected;
        bulkDeleteButton.style.display = anySelected ? 'inline-block' : 'none';
      }
      if (mergeSelectedButton) {
        mergeSelectedButton.disabled = selectedCount < 2;
        mergeSelectedButton.style.display = selectedCount >= 2 ? 'inline-block' : 'none';
      }
    }

    document.querySelectorAll('.playlist-select').forEach((checkbox) => {
      checkbox.addEventListener('change', updateBulkState);
    });

    const selectByCount = document.getElementById('select-by-count');
    if (selectByCount) {
      selectByCount.addEventListener('click', () => {
        const threshold = parseInt(countInput.value, 10);
        if (Number.isNaN(threshold)) {
          alert('Enter a valid number.');
          return;
        }
        document.querySelectorAll('.playlist-list li').forEach((li) => {
          const count = parseInt(li.dataset.count || '0', 10);
          const checkbox = li.querySelector('.playlist-select');
          if (checkbox) {
            checkbox.checked = count <= threshold;
          }
        });
        updateBulkState();
      });
    }

    if (bulkDeleteButton) {
      bulkDeleteButton.addEventListener('click', async () => {
        const selected = Array.from(document.querySelectorAll('.playlist-select:checked'))
          .map((checkbox) => checkbox.closest('li'))
          .filter(Boolean);
        if (!selected.length) return;
        if (!confirm(`Delete ${selected.length} playlist(s)?`)) return;
        bulkDeleteButton.disabled = true;
        const originalLabel = bulkDeleteButton.textContent;
        const total = selected.length;
        let completed = 0;
        const failures = [];
        bulkDeleteButton.textContent = `Deleting... ${completed} of ${total}`;
        for (const li of selected) {
          const playlistId = li.dataset.playlistId;
          if (!playlistId) {
            completed += 1;
            bulkDeleteButton.textContent = `Deleting... ${completed} of ${total}`;
            continue;
          }
          try {
            const response = await fetch(`/delete/${playlistId}`, {
              method: 'POST',
              headers: { 'X-Requested-With': 'XMLHttpRequest' },
            });
            const data = await response.json();
            if (data.success) {
              delete videoCache[playlistId];
              li.remove();
            } else {
              failures.push(playlistId);
            }
          } catch {
            failures.push(playlistId);
          }
          completed += 1;
          bulkDeleteButton.textContent = `Deleting... ${completed} of ${total}`;
        }
        if (failures.length) {
          alert('Some playlists could not be deleted.');
        }
        bulkDeleteButton.textContent = originalLabel;
        updateBulkState();
      });
    }

    async function startMerge(event) {
      if (event) {
        event.preventDefault();
      }
      if (mergeStatus) {
        mergeStatus.textContent = 'Merge button clicked.';
      }
      const selected = Array.from(document.querySelectorAll('.playlist-select:checked'))
        .map((checkbox) => checkbox.closest('li'))
        .filter(Boolean);
      if (selected.length < 2) {
        alert('Select at least two playlists to merge.');
        return;
      }
      const sorted = selected
        .map((li) => ({
          li,
          id: li.dataset.playlistId,
          count: parseInt(li.dataset.count || '0', 10),
        }))
        .sort((a, b) => b.count - a.count);
      const target = sorted[0];
      const sources = sorted.slice(1);
      mergeSelectedButton.disabled = true;
      const originalLabel = mergeSelectedButton.textContent;
      mergeSelectedButton.textContent = 'Merging...';
      const totalToTransfer = sources.reduce((sum, item) => sum + (item.count || 0), 0);
      let transferred = 0;
      if (mergeStatus) {
        mergeStatus.textContent = `Transferring: ${transferred} of ${totalToTransfer}`;
      }
      let hasFailures = false;
      for (let i = 0; i < sources.length; i += 1) {
        const source = sources[i];
        const isLast = i === sources.length - 1;
        try {
          const response = await fetch('/merge-playlists', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest',
            },
            body: JSON.stringify({
              target_id: target.id,
              source_ids: [source.id],
              new_name: null,
            }),
          });
          const data = await response.json();
          if (!data.success && data.failures && data.failures.length) {
            hasFailures = true;
          }
          delete videoCache[source.id];
          source.li.remove();
        } catch {
          hasFailures = true;
        }
        transferred += source.count || 0;
        if (mergeStatus) {
          mergeStatus.textContent = `Transferring: ${transferred} of ${totalToTransfer}`;
        }
      }
      delete videoCache[target.id];
      if (hasFailures) {
        alert('Some playlists could not be merged.');
      }
      const newCount = sorted.reduce((sum, item) => sum + (item.count || 0), 0);
      target.li.dataset.count = `${newCount}`;
      const metaEl = target.li.querySelector('.meta');
      if (metaEl) metaEl.textContent = `${newCount} videos`;
      const checkbox = target.li.querySelector('.playlist-select');
      if (checkbox) checkbox.checked = false;
      mergeSelectedButton.textContent = originalLabel;
      if (mergeStatus) {
        mergeStatus.textContent = 'Merge complete.';
        setTimeout(() => {
          mergeStatus.textContent = '';
        }, 1500);
      }
      updateBulkState();
    }

    if (mergeSelectedButton) {
      mergeSelectedButton.addEventListener('click', startMerge);
    }
    window.startMerge = startMerge;

    /* ── Import videos logic ── */
    const importModalOverlay = document.getElementById('import-modal-overlay');
    const importTextarea = document.getElementById('import-textarea');
    const importFile = document.getElementById('import-file');
    const importDestination = document.getElementById('import-destination');
    const importStatus = document.getElementById('import-status');
    const importSubmitButton = document.getElementById('import-submit');
    const importCancelButton = document.getElementById('import-cancel');
    const importVideosButton = document.getElementById('import-videos-button');

    function parseVideoInput(text) {
      if (!text || !text.trim()) return [];
      const lines = text.split(/\r?\n/);
      const ids = new Set();

      /* Detect Google Takeout CSV: look for a header row containing "Video Id" or "Video ID" */
      let csvVideoIdCol = -1;
      const firstLine = lines[0].trim();
      if (firstLine.includes(',')) {
        const headers = firstLine.split(',').map((h) => h.trim().toLowerCase());
        csvVideoIdCol = headers.findIndex((h) => h === 'video id' || h === 'video id ');
        if (csvVideoIdCol === -1) {
          /* Try "Video Id" with any casing */
          csvVideoIdCol = headers.findIndex((h) => h.replace(/\s+/g, '').toLowerCase() === 'videoid');
        }
      }

      const startIdx = csvVideoIdCol >= 0 ? 1 : 0;

      for (let i = startIdx; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        if (csvVideoIdCol >= 0) {
          /* CSV mode: extract the video ID column */
          const cols = line.split(',');
          const val = (cols[csvVideoIdCol] || '').trim();
          if (val && /^[A-Za-z0-9_-]{11}$/.test(val)) {
            ids.add(val);
          }
          continue;
        }

        /* Try to extract video ID from various YouTube URL formats */
        let match;
        /* youtube.com/watch?v=VIDEO_ID */
        match = line.match(/[?&]v=([A-Za-z0-9_-]{11})/);
        if (match) { ids.add(match[1]); continue; }
        /* youtu.be/VIDEO_ID */
        match = line.match(/youtu\.be\/([A-Za-z0-9_-]{11})/);
        if (match) { ids.add(match[1]); continue; }
        /* youtube.com/embed/VIDEO_ID */
        match = line.match(/youtube\.com\/embed\/([A-Za-z0-9_-]{11})/);
        if (match) { ids.add(match[1]); continue; }
        /* youtube.com/shorts/VIDEO_ID */
        match = line.match(/youtube\.com\/shorts\/([A-Za-z0-9_-]{11})/);
        if (match) { ids.add(match[1]); continue; }
        /* youtube.com/v/VIDEO_ID */
        match = line.match(/youtube\.com\/v\/([A-Za-z0-9_-]{11})/);
        if (match) { ids.add(match[1]); continue; }
        /* Plain 11-char video ID */
        const trimmed = line.split(/[\s,;]+/)[0].trim();
        if (/^[A-Za-z0-9_-]{11}$/.test(trimmed)) {
          ids.add(trimmed);
        }
      }
      return Array.from(ids);
    }

    function openImportModal() {
      if (!importModalOverlay) return;
      /* Pre-select current playlist if one is active */
      if (importDestination && currentPlaylistId) {
        importDestination.value = currentPlaylistId;
      }
      if (importTextarea) importTextarea.value = '';
      if (importFile) importFile.value = '';
      if (importStatus) importStatus.textContent = '';
      importModalOverlay.classList.add('visible');
    }

    function closeImportModal() {
      if (!importModalOverlay) return;
      importModalOverlay.classList.remove('visible');
    }

    if (importVideosButton) {
      importVideosButton.addEventListener('click', openImportModal);
    }
    if (importCancelButton) {
      importCancelButton.addEventListener('click', closeImportModal);
    }
    if (importModalOverlay) {
      importModalOverlay.addEventListener('click', (e) => {
        if (e.target === importModalOverlay) closeImportModal();
      });
    }

    /* File upload: read file and populate textarea */
    if (importFile) {
      importFile.addEventListener('change', () => {
        const file = importFile.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          if (importTextarea) {
            importTextarea.value = e.target.result;
          }
        };
        reader.onerror = () => {
          if (importStatus) importStatus.textContent = 'Failed to read file.';
        };
        reader.readAsText(file);
      });
    }

    /* Import submit */
    if (importSubmitButton) {
      importSubmitButton.addEventListener('click', async () => {
        const text = importTextarea ? importTextarea.value : '';
        const videoIds = parseVideoInput(text);
        if (!videoIds.length) {
          if (importStatus) importStatus.textContent = 'No valid video IDs found.';
          return;
        }
        const destId = importDestination ? importDestination.value : '';
        if (!destId) {
          if (importStatus) importStatus.textContent = 'Please select a destination playlist.';
          return;
        }

        importSubmitButton.disabled = true;
        const originalLabel = importSubmitButton.textContent;
        importSubmitButton.textContent = 'Importing...';
        if (importStatus) importStatus.textContent = `Importing ${videoIds.length} video(s)...`;

        try {
          const response = await fetch(`/playlist/${destId}/import`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest',
            },
            body: JSON.stringify({ video_ids: videoIds }),
          });
          const data = await response.json();
          if (data.success) {
            const added = data.added || 0;
            const failures = data.failures || [];
            let msg = `Successfully added ${added} video(s).`;
            if (failures.length) {
              msg += ` ${failures.length} failed.`;
            }
            if (importStatus) importStatus.textContent = msg;

            /* Invalidate cache for destination playlist */
            delete videoCache[destId];

            /* Update sidebar count and total */
            updatePlaylistCount(destId, added);
            updateTotalVideos(added);

            /* If currently viewing this playlist, reload it */
            if (currentPlaylistId === destId) {
              const row = document.querySelector(`.playlist-list li[data-playlist-id="${destId}"]`);
              const title = row ? row.querySelector('.playlist-link')?.textContent?.trim() : '';
              loadPlaylistVideos(destId, title, row);
            }

            /* Clear the textarea after success */
            if (importTextarea) importTextarea.value = '';
            if (importFile) importFile.value = '';
          } else {
            if (importStatus) importStatus.textContent = data.error || 'Import failed.';
          }
        } catch {
          if (importStatus) importStatus.textContent = 'Import request failed.';
        } finally {
          importSubmitButton.textContent = originalLabel;
          importSubmitButton.disabled = false;
        }
      });
    }
  </script>
{% endblock %}
